<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ primer第八章笔记]]></title>
    <url>%2F2018%2F05%2F18%2FC%2B%2B%20primer%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[标签 ： C++ 读书笔记 IO库IO库是用来做什么的 处理输入输出，向设备读取或者写入数据，这些设备可以是文件、控制台窗口、string IO库有哪些设施 IO类型间的关系无论是从控制台、文件读取对象；还是读取char或者string对象都使用一样的IO操作，这是因为IO标准库定义了继承机制，继承机制有一个特点就是派生类对象能像基类对象一样使用。 因为iftream和istringstream都继承自istream，所以ifstream和istringstream对象的很多操作和istream一样，但是派生类也会有一些不同于基类的新功能。 IO类IO库特性 IO对象无拷贝或者赋值（函数的形参和返回类型不能是IO类型）进行IO操作的函数通常以引用方式传递流类型因为读写会改变IO所以传递返回的引用不能够是const类型 IO库的条件状态IO库的条件状态能够表示IO流是否出错，错误类型是什么，能否修复。类型： iostate 表示条件状态cin.rdstate() 返回iostatebadbit 表示系统级错误，一旦被置位不可用,此时failbit 也被置位failbit 表示可恢复错误（比如输入类型不对）eofbit 达到文件结束，同时 failbit也会被置位goodbit 表示流未发生错误cin.bad() 如果badbit被置位返回true 注意：badbit,failbit,eofbit任意一个被置位则流的状态检验while(cin&gt;&gt;word)会失败.while(cin&gt;&gt;word)相当于while(!=fail()) 管理条件状态记录当前状态1auto old_state=cin.rdstate();//记住cin的当前状态 置为原有状态1cin.setstate(old_state);//将cin还原为原有状态 清除所有错误标志位1cin.clear();//此时调用good会返回true 复位单一的状态位1cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit);//第一位读出当前状态，后面的按位复位 管理输出缓冲为什么有缓冲区：因为设备的写操作很费时，所以把多个输出操作组合成单一的写操作可以带来性能提升，由此引入缓冲区为多个输出操作提供缓存。 比如:cout&lt;&lt;”hello” 字符串”hello”有可能被放入缓冲区 缓冲区刷新的原因： main函数return时缓冲区满的时候，为了写入新的数据显式刷新关联流，会导致关联到的流刷新（cin和cerr关联cout，刷新时cout刷新） 注：程序崩溃，缓冲区不会刷新，所以不会打印 缓冲区显式刷新的例子 endl 打印换行后刷新flush 直接刷新ends 打印空格后刷新unitbuf 每次写立即刷新缓冲区nounitbuf 回到正常模式 文件输入输出文件输入输出由fstream头文件管理，fstream由于继承自iostream所以大部分操作和iostream一样，但是有一些新的成员来管理文件 fstream特有操作 fstream f1; //定义一个未绑定的文件流f1fstream f1(s); //把名为s的文件绑定到文件流f1f1.open(s1); //与上同f1.close(); 注：接收ostream&amp;的参数可以传递ofstream 成员函数open和close检查open打开文件是否成功123ofstream out;//创建文件输出流out.open(file);//将流与文件关联if(out);//检查open是否成功 注：不能两次open同一个文件流，需要先close。但是如果在局部作用域如for中，则不用close因为局部作用域自动创建销毁。 文件模式 in以读的方式打开out以写的方式打开app每次写操作定位到文件末尾ate打开文件后定位到文件末尾trunc截断文件binary以二进制的方式进行IO ofstram默认被截断12345678ofstream out("file1");ofstream out("file1",ofstream::out);ofstream out("file1",ofstream::out|ofstream::trunc);//以上三种均被截断......................................................................................ofstream out("file1",ofstream::out|ofstream::app);ofstream out;out.open("file1",ofstream::app);//以上两种不会被覆盖。用app可以保留之前写的文件内容，下一次写从末尾开始 string流string流由头文件sstream管理，头文件有ostringstream、istringstream、stringstream三个类 stringstream特有操作 sstream strm;//定义一个string流sstream strm(s);//定义一个string流保存string s的一个拷贝strm.str();//返回strm保存的string拷贝strm.str(s);//将s这个string的拷贝保存到strm这个流对象，返回void 使用istringstream123456789101112131415struct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;;//定义一个结构体每个人有多个电话号码...string line,word;vector&lt;PersonInfo&gt; people; //用于存储多个结构体信息while(getline(cin,line))&#123; //每次从控制台读取一行给line这个string PersonInfo info; //定义一个保存记录的对象 istringstream record(line); //将记录绑定到刚刚读入的行 record&gt;&gt;info.name(); //读取名字 while(record&gt;&gt;word) //读取多个电话号码 info.phones.push_back(word); people.push_back(info); //将所有记录保存&#125; 使用ostringstream12345ostringstream os;string str1="hello";string str2="world";os&lt;&lt;str1&lt;&lt;" "&lt;&lt;str2;cout&lt;&lt;os.str()&lt;&lt;endl; //输出hello world]]></content>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
